# Architectural Decisions

**Purpose:** Explain *why* things are the way they are. Read before "fixing" something that looks wrong.

---

## D001: stdin Must Be Null

**Decision:** Use `stdin(Stdio::null())` when spawning Claude process.

**Context:**
Claude CLI expects interactive terminal input. When stdin is piped, it blocks forever waiting for input that never comes in the format it expects.

**Alternatives Considered:**
- `Stdio::piped()` with writes → Blocks indefinitely
- Named pipes → Too complex, platform-specific
- PTY → Overhead, complexity for non-interactive use

**Solution:**
- Pass prompt as CLI argument: `claude -p "prompt here"`
- Use `--resume {sessionId}` for follow-up messages
- Spawn new process per message

**Consequences:**
- Process overhead per message (acceptable)
- Must track `claudeSessionId` for resume
- Works reliably across all scenarios

**Code Location:** `src-tauri/src/claude/process.rs`

---

## D002: Two ID System (uiId vs claudeSessionId)

**Decision:** Maintain two separate IDs for each session.

**Context:**
We need an ID immediately when user creates a session (for store keys, React keys, tabs). But Claude's session ID only exists after first message is sent and `system` event arrives.

**Why Not Just Use Claude's ID?**
- Can't - it doesn't exist yet when session is created
- Discovered sessions complicate this (they start with Claude's ID)
- Resume can fail silently → Claude creates new session with different ID

**Solution:**
```
uiId (nanoid)        → Always present, generated by us
claudeSessionId      → Null until first system event, then Claude's UUID
```

**Mapping:**
- Store keys, React keys, tabs → uiId
- `--resume`, transcript paths → claudeSessionId
- Discovered sessions → both set to same value (Claude's ID)

**Consequences:**
- Must always be clear which ID a function expects
- `updateSession(uiId, { claudeSessionId })` after first system event
- Refs must sync to null when switching to new session (no claudeSessionId yet)

**Code Locations:**
- `src/domain/session.ts` - Type definitions
- `src/store/slices/sessions.ts` - Session management
- `src-tauri/src/claude/process.rs` - Resume logic

---

## D003: Session-Centric Store with Indexes

**Decision:** Store is keyed by session, each session contains its own messages and tool indexes.

**Context:**
Tool updates arrive frequently (every tool start, progress, completion). Original flat store required O(n) search through all messages to find and update a tool.

**Previous Structure:**
```ts
messages: { [sessionId]: ParsedMessage[] }  // Separate from sessions
// Finding tool = flatMap all messages, search for ID
```

**Current Structure:**
```ts
sessions: {
  [uiId]: {
    session: Session,
    messages: ParsedMessage[],
    toolsById: Record<string, ToolCall>,        // O(1) lookup
    toolMessageIds: Record<string, string>,     // tool → message
    messageIndexById: Record<string, number>,   // message → index
  }
}
```

**Why Indexes?**
- `toolsById[toolId]` → O(1) vs O(n) for every tool update
- `toolMessageIds[toolId]` → Know which message to update
- `messageIndexById[messageId]` → Direct array access

**Consequences:**
- Must maintain indexes when adding/updating messages
- Store actions handle this automatically
- Never modify `messages[]` directly - use store actions

**Code Locations:**
- `src/store/types.ts` - SessionState interface
- `src/store/helpers.ts` - buildMessageIndexes()
- `src/store/slices/chat.ts` - Index maintenance

---

## D004: Typed BackendEvent Protocol

**Decision:** All backend→frontend events flow through `horseman-event` as typed `BackendEvent` discriminated union.

**Context:**
Originally had three separate channels with separate listeners. Evolved to single channel with source wrapper. Now fully typed with discriminated union.

**Current Structure:**
```ts
type BackendEvent =
  | { type: 'session.started'; uiSessionId: string; claudeSessionId: string }
  | { type: 'session.ended'; uiSessionId: string; exitCode: number | null; error?: string }
  | { type: 'message.assistant'; uiSessionId: string; message: Message }
  | { type: 'tool.started'; uiSessionId: string; tool: ToolCall }
  | { type: 'tool.completed'; uiSessionId: string; toolId: string; output: string }
  // ... etc
```

**Why Typed Protocol?**
- TypeScript exhaustiveness checking in switch
- Rust types mirror frontend types (serde Serialize)
- No parsing in frontend - Rust emits ready-to-use data
- Clear contract between Rust and TypeScript

**Evolution:**
1. Three channels → One channel with source wrapper → Typed discriminated union
2. Frontend parsing → Rust parsing → Rust emits typed events

**Consequences:**
- Frontend is dumb renderer (no parsing logic)
- Rust owns all Claude JSON parsing
- Type changes require Rust + TS updates
- Clean switch statement in `useHorsemanEvents`

**Code Locations:**
- `src/domain/protocol.ts` - TypeScript event types
- `src-tauri/src/claude/process.rs` - Rust event types + emission
- `src/hooks/useHorsemanEvents.ts` - Single typed listener

---

## D005: MCP for Permissions (Not stdin)

**Decision:** Use MCP (Model Context Protocol) server for permission requests instead of stdin.

**Context:**
Claude's `--permission-prompt-tool` flag allows specifying an MCP tool to handle permission requests. This is the official supported way to intercept permissions.

**Why Not stdin?**
- See D001 - stdin blocks
- Permission responses have specific format requirements
- MCP provides structured request/response

**Architecture:**
```
Claude → calls mcp__horseman__request_permission
      → horseman-mcp binary receives call
      → POSTs to Tauri HTTP server (Axum)
      → Tauri emits event to frontend
      → User approves/denies
      → Response flows back through MCP
```

**Why Separate Binary (horseman-mcp)?**
- MCP servers must be standalone executables
- Claude spawns them as child processes
- Can't be part of Tauri app directly

**Consequences:**
- Must build and ship horseman-mcp binary
- HTTP server runs alongside Tauri app
- Permissions are global (MCP doesn't know which session)

**Code Locations:**
- `horseman-mcp/src/main.rs` - MCP server
- `src-tauri/src/hooks/server.rs` - Axum HTTP server
- `src-tauri/src/hooks/mod.rs` - MCP config generation

---

## D006: Permissions Are Global (MCP Limitation)

**Decision:** Don't filter permissions by session ID.

**Context:**
MCP permission requests don't include Claude's session ID. The `sessionId` field in our `PendingPermission` is always `"mcp"`.

**Why This Happens:**
- MCP tool receives tool call, not session context
- horseman-mcp has no way to know which Claude session triggered it
- Claude doesn't expose session ID to MCP tools

**Attempted Solutions:**
- Tried to correlate by timing → unreliable
- Tried to pass through tool input → Claude doesn't include it

**Current Approach:**
- Permissions are global in store
- Show all pending permissions to user
- User approves/denies regardless of which session triggered

**This Is Acceptable Because:**
- Usually only one session running at a time
- User can see which tool is being requested
- Wrong approval = tool runs in wrong session (minor issue)

**Consequences:**
- Never filter `pendingPermissions` by sessionId
- PermissionCard appears for any active session
- Multiple simultaneous sessions = ambiguous (rare edge case)

**Code Locations:**
- `src/store/slices/permissions.ts` - Global storage
- `src/components/permissions/PermissionCard.tsx` - No session filtering

---

## D007: Messages Not Persisted (Rebuilt from Transcripts)

**Decision:** Don't persist messages in Zustand. Rebuild from Claude's transcripts on load.

**Context:**
Claude stores complete conversation history in `~/.claude/projects/{path}/{session-id}.jsonl`. This is the source of truth.

**Why Not Persist Ourselves?**
- Duplication - Claude already stores everything
- Sync issues - our copy could diverge
- Storage bloat - messages can be large (tool outputs)
- Transcripts have more info - raw events vs our parsed form

**What We Persist:**
- Session metadata (name, workingDirectory, status)
- Tab state (openTabIds, activeSessionId)
- Settings (theme, model, sidebarCollapsed)

**What We Don't Persist:**
- Messages (rebuilt from transcript)
- Tool indexes (rebuilt from messages)
- Pending permissions/questions (ephemeral)

**Consequences:**
- Loading discovered session = parse transcript
- Resuming app = sessions exist but messages empty until viewed
- Transcript parsing must handle all Claude event types

**Code Locations:**
- `src/store/index.ts` - partialize for persistence
- `src-tauri/src/commands/sessions.rs` - read_session_transcript
- `src/lib/parseClaudeEvents.ts` - Transcript parsing

---

## D008: Selectors with Stable Empty Arrays

**Decision:** Selectors return stable empty array references, not inline `[]`.

**Context:**
Zustand uses reference equality for change detection. If selector returns new `[]` every render, Zustand thinks state changed → re-render → new `[]` → infinite loop.

**The Bug:**
```ts
// BAD - new [] every render
const messages = useStore(s => s.sessions[id]?.messages ?? [])
```

**The Fix:**
```ts
// GOOD - stable reference
const EMPTY_MESSAGES: ParsedMessage[] = []
const messages = useStore(s => s.sessions[id]?.messages ?? EMPTY_MESSAGES)
```

**Why This Happens:**
- `[]` creates new array object
- `[] !== []` (reference equality)
- Zustand sees "different" → triggers re-render
- Re-render creates new `[]` → cycle

**Solution:**
- Stable empty arrays defined outside components
- Selectors in `src/store/selectors.ts` handle this
- Components MUST use selectors, not inline store access

**Consequences:**
- All store reads should go through selectors
- Adding new selectors must follow this pattern
- Direct `useStore` in components is a code smell

**Code Location:** `src/store/selectors.ts`

---

## D009: Refs for Async Event Filtering

**Decision:** Use refs (not state/closure values) to filter events in async callbacks.

**Context:**
Event listeners are registered once and receive events continuously. If they capture state in closure, they see stale values.

**The Bug:**
```ts
useEffect(() => {
  listen('event', (e) => {
    // BUG: activeSessionId is stale (captured at effect registration)
    if (e.sessionId === activeSessionId) { ... }
  })
}, [])  // Empty deps = never re-registers
```

**The Fix:**
```ts
const activeSessionIdRef = useRef(activeSessionId)
activeSessionIdRef.current = activeSessionId  // Sync EVERY render

useEffect(() => {
  listen('event', (e) => {
    // CORRECT: ref.current is always fresh
    if (e.sessionId === activeSessionIdRef.current) { ... }
  })
}, [])
```

**Why Refs?**
- Refs are mutable boxes
- `.current` always reflects latest value
- No need to re-register listener when value changes

**Critical Detail:**
```ts
// Sync must happen in component body, not in effect
activeSessionIdRef.current = activeSessionId  // ← Every render!
```

**Ref Must Sync to Null:**
```ts
// WRONG - leaves stale ID
if (claudeSessionId) {
  ref.current = claudeSessionId
}

// RIGHT - clears when switching to new session
ref.current = claudeSessionId || null
```

**Consequences:**
- Event handlers use refs, not state
- Refs sync on every render (not in effect)
- Null sync prevents session bleed

**Code Locations:**
- `src/hooks/useHorsemanEvents.ts` - Event filtering
- RULES.md - Pattern documentation

---

## D010: New Process Per Message (Consequence of D001)

**Decision:** Spawn new Claude process for each message, use `--resume` for continuity.

**Context:**
Since stdin is null (D001), we can't send follow-up messages to running process. Must start new process with `--resume` flag.

**Flow:**
```
Message 1: claude -p "hello"                    # New session
Message 2: claude -p --resume {id} "follow up"  # Resume
Message 3: claude -p --resume {id} "another"    # Resume same
```

**Why This Works:**
- Claude persists conversation in transcript
- `--resume` loads transcript and continues
- Process exits after each response, new process picks up

**Overhead:**
- Process spawn per message (acceptable)
- Claude loads transcript each time (fast for typical sizes)
- No long-running process to manage

**Benefits:**
- Simpler state management
- No zombie process issues
- Clean separation between messages

**Consequences:**
- Must capture `claudeSessionId` from first `system` event
- Must pass correct ID to `--resume`
- If resume fails, Claude creates new session (different ID)

**Code Location:** `src-tauri/src/claude/process.rs`

---

## D011: Domain Types as Single Source of Truth

**Decision:** All types live in `src/domain/`, other locations re-export.

**Context:**
Types were scattered across:
- `src/types/session.ts`
- `src/components/chat/types.ts`
- `src/store/types.ts`

This led to:
- Duplicate/inconsistent definitions
- Unclear which to import
- Circular dependency risks

**Current Structure:**
```
src/domain/
├── session.ts      # Session, SessionUsage, etc.
├── message.ts      # Message, ToolCall, FileBlock
├── permission.ts   # PendingPermission
├── question.ts     # PendingQuestion
├── todo.ts         # TodoItem
├── protocol.ts     # BackendEvent
└── index.ts        # Re-exports all
```

**Migration Path:**
- `src/types/` re-exports from `@/domain`
- Gradually update imports to `@/domain`
- Eventually remove legacy paths

**Consequences:**
- Always import from `@/domain`
- `@/types` exists for backwards compatibility
- New types go in appropriate domain file

**Code Location:** `src/domain/`

---

## D012: Tool Result Arrives Separately from Tool Call

**Decision:** Tool results update existing tools, they don't create new messages.

**Context:**
Claude sends events in this order:
```
assistant event (tool A)  → We create message with ToolCall status: 'running'
assistant event (tool B)  → We create another message
user event (results A, B) → We update existing tools to status: 'completed'
```

**Key Insight:**
- One assistant event PER tool call (not batched)
- Results arrive in single user event (batched)
- Must match results to tools by `tool_use_id`

**Why This Matters:**
- Can't assume tool is in "last message"
- Must search by tool ID (hence indexes - D003)
- Multiple tools may complete in any order

**Consequences:**
- `updateToolOutput` searches by tool ID
- Indexes enable O(1) lookup
- Tool status transitions: pending → running → completed/error

**Code Locations:**
- `src/lib/parseClaudeEvents.ts` - Event parsing
- `src/store/slices/chat.ts` - updateToolOutput

---

## D013: Parsing Happens in Rust

**Decision:** All Claude JSON parsing happens in Rust. Frontend receives ready-to-use typed data.

**Context:**
Originally frontend parsed Claude's raw JSON events. This meant:
- Parsing logic duplicated for live stream and transcript loading
- TypeScript parsing was fragile (lots of `.get()?.as_str()?`)
- Business logic (tool matching, todo extraction) split across languages

**Current Architecture:**
```
Live Streaming:
Claude stdout → [Rust] parse_assistant_event() → emit BackendEvent → [Frontend] switch handler

Transcript Loading:
Transcript file → [Rust] parse_transcript_content() → TranscriptParseResult → [Frontend] normalize timestamps
```

**Why Rust Parsing?**
- Single parsing implementation for both live and transcript
- Rust's serde is robust for JSON handling
- Frontend becomes pure renderer
- Easier to maintain/debug parsing logic

**Timestamp Handling:**
- Rust emits timestamps as ISO 8601 strings (`Utc::now().to_rfc3339()`)
- Frontend normalizes to `Date` objects: `new Date(message.timestamp)`
- This avoids serialization issues with Date across Tauri boundary

**Key Functions:**
- `parse_assistant_event()` - Live stream event parsing
- `parse_transcript_content()` - Full transcript parsing
- `normalizeTranscriptMessage()` - Frontend timestamp conversion

**Consequences:**
- `parseClaudeEvents.ts` being deprecated (only transcript legacy)
- Tool result matching happens in Rust
- Todo extraction happens in Rust
- Type definitions must stay in sync (Rust + TS)

**Code Locations:**
- `src-tauri/src/claude/process.rs` - All parsing logic
- `src/lib/ipc.ts` - TranscriptParseResult type
- `src/App.tsx` - normalizeTranscriptMessage()

---

## D014: Tool Results Matched by Rust

**Decision:** Rust matches tool results to tool calls during parsing, not frontend.

**Context:**
Claude sends tool calls and results separately:
```
assistant event: { tool_use: { id: "toolu_xxx", ... } }
user event: { tool_result: { tool_use_id: "toolu_xxx", content: "..." } }
```

Previously frontend had to correlate these. Now Rust does it.

**Live Streaming:**
- `tool.started` emitted with `status: 'running'`
- `tool.completed` or `tool.error` emitted when result arrives
- Frontend just updates by toolId

**Transcript Loading:**
- `parse_transcript_content()` builds `tool_results: HashMap<String, ToolResult>`
- When building messages, looks up results by tool_use_id
- Returns messages with tool status already set

**ToolResult in Rust:**
```rust
struct ToolResult {
    output: String,
    is_error: bool,
}
```

**Consequences:**
- Frontend doesn't need to track pending tools
- Tool status transitions happen atomically
- Error status properly propagated via `is_error` flag

**Code Location:** `src-tauri/src/claude/process.rs`

---

## D015: Session Events (Horseman's Metadata Layer)

**Decision:** Store Horseman-specific events (compaction, permissions, slash commands) in `session.events[]`, separate from Claude's messages.

**Context:**
Claude's transcript is the source of truth for messages. But Horseman needs to track context *around* the conversation that Claude doesn't know about:
- When was context compacted? (Claude has `summary` events but no timestamps)
- What permissions were approved/denied? (MCP doesn't log this)
- When did slash commands run?

**Why Not Store in Messages?**
- Messages are ephemeral (rebuilt from transcript on load)
- Mixing our events with Claude's messages is confusing
- Permission/slash events don't have corresponding Claude events

**Why Not Duplicate Messages?**
- Storage waste - Claude already stores everything
- Sync nightmares - our copy would diverge
- Claude's transcript is authoritative

**Solution:**
```ts
type SessionEvent =
  | { type: 'compacted'; timestamp: string; summary: string }
  | { type: 'permission'; timestamp: string; tool: string; allowed: boolean; path?: string }
  | { type: 'slash'; timestamp: string; command: string; status: 'completed' | 'error' }
```

- Stored in `session.events[]` (persisted with session metadata)
- Logged when: compact completes, permission resolves, slash finishes
- UI renders compaction events as dividers in MessageList
- Transcript summaries → converted to compaction events on load

**Consequences:**
- Can show full message history AND compaction markers
- Permission decisions are auditable
- Slash command history is preserved
- Small storage footprint (just metadata, not messages)

**Code Locations:**
- `src/domain/session.ts` - SessionEvent type
- `src/store/slices/sessions.ts` - appendSessionEvent()
- `src/components/chat/ChatView.tsx` - logs events on slash complete
- `src/components/permissions/PermissionCard.tsx` - logs permission events
- `src/components/chat/MessageList.tsx` - renders compaction dividers
- `src-tauri/src/claude/process.rs` - parses transcript summaries

---

## D016: Two-Pass Transcript Parsing + Subagent Loading

**Decision:** Transcript parsing uses two passes, and loads subagent transcripts recursively.

**Context:**
Two problems discovered when loading historical sessions:

1. **Tool Status Bug:** Tools showed as "pending" (stuck spinner) instead of "completed"
2. **Missing Subagent Tools:** Task tools showed no children on reload

**Problem 1: Tool Result Ordering**

Claude's transcript JSONL is ordered:
```
1. user event (prompt)
2. assistant event (tool_use) → creates tool
3. user event (tool_result) → has completion data
```

Single-pass parsing saw `assistant` event, created tool with `status: "running"`, checked `tool_results` HashMap (empty!), moved on. The `user` event with results came later.

**Solution:** Two-pass approach in `parse_transcript_content()`:
- Pass 1: Parse all events, collect tool_results into HashMap, **merge duplicate message IDs**
- Pass 2: Iterate messages, apply any remaining tool_results

**Problem 1b: Duplicate Message IDs (React Key Collision)**

Claude emits **multiple `assistant` events with the same `message.id`** - one per tool call. Without merging, we create duplicate messages → React key collision errors.

**Solution:** Track `message_index_by_id: HashMap<String, usize>`. When seeing `assistant` event:
- If message ID exists → merge text and tools into existing message
- If new → create new message and track its index

**Problem 2: Subagent Transcripts**

Task tools spawn subagents that log to separate files: `{agentId}.jsonl`. These weren't loaded during historical session loading (only during live streaming).

**Solution:** `parse_transcript_with_subagents()`:
- Parse main transcript
- For each Task tool with `agentId` in output:
  - Load `{parentDir}/{agentId}.jsonl`
  - Parse with `parse_transcript_content()`
  - Set `parentToolId` on all child tools
  - Update Task's `subagent.toolCount`
- Return `subagentTools[]` separately (not in messages)

**Frontend Handling:**
- `setMessages()` builds indexes from main transcript tools
- `mergeSubagentTools()` adds subagent tools to `toolsById` (no parent message)
- `useAllTools()` selector returns all tools from `toolsById`
- `MessageList` receives `allTools` prop (includes subagent tools)

**Performance:**
- Parsing happens once per session load
- ~1-5 extra file reads for sessions with Tasks
- Acceptable tradeoff for correct UI

**Consequences:**
- Historical sessions show completed tool checkmarks
- SubagentDisplay shows tool counts and child tools on expand
- `allTools` must come from store (not flatMap of messages)

**Code Locations:**
- `src-tauri/src/claude/process.rs` - Two-pass logic (lines 852-867), `parse_transcript_with_subagents()`
- `src-tauri/src/commands/sessions.rs` - Uses `parse_transcript_with_subagents`
- `src/lib/ipc.ts` - `TranscriptParseResult.subagentTools`
- `src/store/slices/chat.ts` - `mergeSubagentTools()`
- `src/store/selectors.ts` - `useAllTools()`
- `src/App.tsx` - Calls `mergeSubagentTools` after `setMessages`
- `src/components/chat/MessageList.tsx` - Receives `allTools` prop

---

## D017: Diffs Syntax Highlighting Uses Token CSS Vars in Fallback

**Decision:** Keep `DIFFS_UNSAFE_CSS_FALLBACK` mapped to token variables
(`--diffs-token-light/dark` and token background vars) and always pass `unsafeCSS`
to diffs components.

**Context:**
`@pierre/diffs` renders in Shadow DOM and relies on `light-dark()` plus token CSS
variables for Shiki colors. On older WebViews that lack `light-dark()` support, a
fallback is required. If the fallback uses only `--diffs-light/--diffs-dark`, all
tokens collapse to a single color even though highlight callbacks fire.

**Alternatives Considered:**
- Remove fallback entirely → works only on modern engines.
- Use base `--diffs-light/--diffs-dark` for token color → breaks syntax coloring.

**Consequences:**
- Do not simplify the fallback or remove `unsafeCSS` from `CodeDisplay` /
  `DiffDisplay`.
- Theme tweaks should use `diffs-container` overrides or token vars, not global text color.

**Code Locations:**
- `src/lib/diffs.ts` - `DIFFS_UNSAFE_CSS_FALLBACK`
- `src/components/chat/CodeDisplay.tsx` - `unsafeCSS` wiring
- `src/components/chat/DiffDisplay.tsx` - `unsafeCSS` wiring
- `src/providers/DiffsProvider.tsx` - worker pool / theme config
- `src/styles/globals.css` - `diffs-container` overrides

---

## D018: /clear Starts Fresh Session (No Resume)

**Decision:** After `/clear`, clear `claudeSessionId` so next message spawns a new Claude session instead of resuming.

**Context:**
`/clear` in CLI writes events to the transcript but doesn't delete history. When we `--resume {sessionId}`, Claude loads the ENTIRE transcript including everything before clear. The summary event should tell Claude to ignore old content, but it's still loaded into context.

**Alternatives Considered:**
- Run PTY `/clear` and keep resuming → Claude still sees old transcript
- Wait for PTY to complete before allowing messages → Race condition, complexity
- Parse transcript to find clear point → Over-engineered

**Solution:**
- Clear UI immediately
- Clear `claudeSessionId` from session
- Next message starts a new Claude session (no `--resume`)
- No PTY needed - we're abandoning the old session entirely

**Consequences:**
- Clean context break - Claude truly forgets everything
- New `claudeSessionId` assigned on next message
- Old transcript orphaned (still on disk but not resumed)
- Simple and reliable

**Code Locations:**
- `src/components/chat/ChatView.tsx` - handleSlashCommand /clear case

---

## D019: Compaction Summary Extraction and Context Injection

**Decision:** Extract actual summary from transcript after `/compact`, inject into first message only.

**Context:**
After `/compact`, Claude writes a `{"type":"summary","summary":"..."}` event to the transcript. Previously Horseman showed a hardcoded "Context compacted" string. Claude had no awareness that compaction happened.

**Summary Location:**
Summary events can appear anywhere in the transcript (not just line 1). Multiple compactions = multiple summaries. Extract the LAST one (most recent).

**Extraction:**
- `extract_transcript_summary()` Rust command scans entire transcript
- Returns last `type: "summary"` event's summary field
- Called after `/compact` completes

**Context Injection:**
- Track `session.lastCompactionInjectedAt` timestamp
- On message send, check for compaction newer than last injection
- If found, prepend: `[Context: This conversation was compacted. Summary: {summary}]`
- Mark as injected so subsequent messages don't repeat

**Display vs Send:**
- User message bubble shows original text (no injection visible)
- Claude receives text with context prefix
- `sendMessage(displayText, fileBlocks, sendText)` signature

**Consequences:**
- StatusLine shows actual summary from Claude
- User sees clean message bubble
- Claude receives compaction context on first post-compact message
- Proper context continuity after compaction

**Code Locations:**
- `src-tauri/src/commands/sessions.rs` - extract_transcript_summary(), get_transcript_path()
- `src/lib/ipc.ts` - IPC wrappers
- `src/components/chat/ChatView.tsx` - summary fetch and display
- `src/hooks/useHorsemanEvents.ts` - sendMessage with displayText/sendText
- `src/App.tsx` - handleSendMessage context injection
- `src/domain/session.ts` - lastCompactionInjectedAt field

---

## Adding New Decisions

When making architectural decisions, document them here:

```markdown
## DXXX: Title

**Decision:** What we decided.

**Context:** Why we needed to decide.

**Alternatives Considered:** What else we tried.

**Consequences:** What this means for the codebase.

**Code Locations:** Where this is implemented.
```
