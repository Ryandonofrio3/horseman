# Horseman Rules

**Read this before making changes. If unsure, ASK.**

---

## üö® CRITICAL: Will Break Things If Wrong

### 1. Two Session IDs (UI vs Claude)

| ID | Generated By | Used For |
|----|--------------|----------|
| **UI Session ID** (`id`) | Us (nanoid) | Store keys, tabs, sidebar |
| **Claude Session ID** (`claudeSessionId`) | Claude CLI | `--resume`, transcripts |

They are NOT the same. A new UI session has no Claude ID until first message.

**Flow:**
1. New session ‚Üí UI ID only, `claudeSessionId = undefined`
2. First message ‚Üí spawn Claude (no `--resume`)
3. `system` event ‚Üí extract Claude's `session_id`, store as `claudeSessionId`
4. Follow-ups ‚Üí `--resume {claudeSessionId}`

### 2. Stdin is Cursed

**Never use `stdin(Stdio::piped())`** - Claude blocks forever.

**Solution:** `stdin(Stdio::null())` + prompt as CLI arg + new process per message with `--resume`.

### 3. Refs Must Always Sync

```js
// ‚úÖ CORRECT - always sync, even to null
useEffect(() => {
  activeClaudeSessionRef.current = claudeSessionId || null
}, [claudeSessionId])

// ‚ùå WRONG - leaves stale IDs when switching sessions
useEffect(() => {
  if (claudeSessionId) {  // Bug: doesn't clear!
    activeClaudeSessionRef.current = claudeSessionId
  }
}, [claudeSessionId])
```

**Why:** Defensive `if` guards cause session bleed. When switching to a new session (no Claude ID), the ref must clear or it'll resume the old session.

### 4. Refs for Async, Not Closures

```js
// ‚úÖ CORRECT - ref updated synchronously each render
const uiSessionIdRef = useRef(uiSessionId)
uiSessionIdRef.current = uiSessionId  // In component body!

if (sessionId === uiSessionIdRef.current) { ... }

// ‚ùå WRONG - closure captures stale value
if (sessionId === uiSessionId) { ... }
```

### 5. Use Selectors, Not Direct Store Access

```ts
// ‚úÖ CORRECT - use selectors from src/store/selectors.ts
import { useSessionMessages, useSessions } from '@/store/selectors'

const messages = useSessionMessages(sessionId)
const sessions = useSessions()

// ‚ùå WRONG - creates new array every render ‚Üí infinite loop
const messages = useStore(s => s.sessions[id]?.messages ?? [])
```

**Why:** Selectors use stable empty arrays (`EMPTY_MESSAGES`). Inline fallbacks like `?? []` create new references every render ‚Üí Zustand thinks state changed ‚Üí infinite re-render.

### 6. Import Types from `@/domain`

```ts
// ‚úÖ CORRECT
import type { Session, ParsedMessage, ToolCall } from '@/domain'

// ‚ùå WRONG - legacy paths, may be removed
import type { Session } from '@/types/session'
import type { ParsedMessage } from '@/components/chat/types'
```

### 7. Maintain Tool Indexes When Modifying Messages

When adding messages with tool calls, the store automatically updates:
- `toolsById[toolId]` ‚Üí the tool object
- `toolMessageIds[toolId]` ‚Üí which message contains it
- `messageIndexById[messageId]` ‚Üí array position

**Never manually modify `messages[]` without going through store actions** - the indexes will be stale.

---

## üîí Don't Change Without Asking

1. `stdin(Stdio::null())` approach
2. Two-ID system (UI vs Claude)
3. Unified event channel (`horseman-event` with `source`)
4. `--resume` for follow-ups (not stdin)
5. `uiSessionIdRef` sync pattern
6. `activeClaudeSessionRef` ALWAYS syncs (even to null)
7. `isDiscovered` stored on Session (not computed)
8. Our UUIDs for React keys (not Claude's `msg_*` IDs)
9. Tool indexes (`toolsById`, `toolMessageIds`, `messageIndexById`)
10. Selectors in `src/store/selectors.ts`
11. Domain types in `src/domain/`

---

## Architecture

### Unified Event System

Single Tauri event channel: `horseman-event`

```ts
type HorsemanEvent =
  | { source: 'claude'; event: ClaudeEvent }
  | { source: 'hook'; event: HookEvent }
  | { source: 'slash'; event: SlashEvent }
```

**All events flow through `useHorsemanEvents.ts`** which routes by `source`.

### Session-Centric Store

```ts
interface SessionState {
  session: Session             // Metadata
  messages: ParsedMessage[]    // Chat history
  toolsById: Record<string, ToolCall>      // O(1) tool lookup
  toolMessageIds: Record<string, string>   // toolId ‚Üí messageId
  messageIndexById: Record<string, number> // messageId ‚Üí index
}

// Store shape
sessions: Record<uiId, SessionState>
```

**Why indexes?** Tool updates arrive constantly. Without: O(n) search per update. With: O(1).

### State Split

| Where | What |
|-------|------|
| **Zustand** | Sessions (with messages, tools, indexes), tabs, settings |
| **Hook state** | Streaming status, errors (ephemeral) |
| **Refs** | Active session IDs (for async event filtering) |

### Event Filtering

Backend emits with `session_id`. Claude's JSON has different `session_id` when:
- Resume fails ‚Üí new session
- Fresh start

Accept events matching EITHER active Claude ID OR pending internal ID. Extract real ID from `system` event.

### Tool Result Matching

Claude sends one `assistant` event PER TOOL, not one event with all tools:
```
assistant event (tool A) ‚Üí message 1
assistant event (tool B) ‚Üí message 2
assistant event (tool C) ‚Üí message 3
user event (results for A, B, C)
```

`updateToolOutput` uses `toolsById` index for O(1) lookup, then updates both the index and the message.

### Duplicate Message IDs in Transcripts (D016)

Claude emits **multiple `assistant` events with the same `message.id`**. In transcripts:
- Live streaming: Each event is processed and merged in real-time
- Transcript parsing: Must track seen IDs and merge, or you get React key collisions

**Solution in `parse_transcript_content()`:**
```rust
let mut message_index_by_id: HashMap<String, usize> = HashMap::new();
// ...
if let Some(&existing_idx) = message_index_by_id.get(&msg_id) {
    // Merge into existing message
} else {
    // New message, track index
    message_index_by_id.insert(msg_id, messages.len());
}
```

---

## Patterns

### Discovered Sessions

Sessions from `~/.claude/projects/`:
- Filename IS the Claude session ID
- Set both `id` and `claudeSessionId` to same value
- Store `isDiscovered: true` on Session (don't compute dynamically)

### Tool Display

**Render order in `ToolOutputContent`** (must return early):
1. Edit ‚Üí DiffDisplay (return!)
2. Write ‚Üí CodeDisplay (return!)
3. Check `if (!tool.output) return null`
4. Read ‚Üí CodeDisplay
5. Bash ‚Üí terminal pre
6. Default ‚Üí plain pre

**Collapse behavior:**
```js
const defaultOpen = isStreaming && (tool.name === 'Edit' || tool.name === 'Write')
```

### Layout Scrolling

```
Parent: overflow-hidden
Scrollable: flex-1 min-h-0  ‚Üê min-h-0 is critical!
```

---

## Permission System (MCP-based)

### Architecture

```
Claude wants tool ‚Üí --permission-prompt-tool intercepts
‚Üí Claude calls mcp__horseman__request_permission
‚Üí horseman-mcp POSTs to Tauri HTTP endpoint
‚Üí Tauri emits { source: 'hook', event: permission_request }
‚Üí User approves/denies in UI
‚Üí Response flows back through MCP
‚Üí Claude continues
```

### Permission & Question Session Isolation

MCP doesn't know Claude's session context. The frontend tags events with the active UI session when received.

```tsx
// ‚úÖ CORRECT - use session-filtered selectors
const permissions = useSessionPermissions(uiSessionId)
const questions = useSessionQuestions(uiSessionId)

// ‚ùå WRONG - shows all sessions' permissions/questions
const permissions = usePendingPermissions()
const questions = usePendingQuestions()
```

**Flow:**
1. MCP emits event with `sessionId: "mcp"` (placeholder)
2. `useHorsemanEvents` receives it, tags with `uiSessionIdRef.current`
3. ChatView uses session-filtered selectors to show only this session's items

### Response Format

```js
// Allow - MUST include updatedInput
{ "behavior": "allow", "updatedInput": { /* original tool input */ } }

// Deny - MUST include message
{ "behavior": "deny", "message": "Reason for denial" }
```

---

## Tool Call Lifecycle

### Event Flow

```
1. assistant event { content: [{ type: "tool_use", id: "toolu_xxx", ... }] }
   ‚Üí parseAssistantEvent creates ToolCall with status: "running"
   ‚Üí addMessage updates toolsById index

2. (if permission needed) MCP permission flow

3. Tool executes

4. user event { content: [{ type: "tool_result", tool_use_id: "toolu_xxx", ... }] }
   ‚Üí updateToolOutput uses toolsById[toolId] for O(1) lookup
   ‚Üí updates both index and message array
```

### Subagent Tool Nesting (Task)

Key rules:
- **Emit order matters:** Emit `StreamEvent` before `ToolUpdate` so tool exists in store
- **Parent linkage:** Use `parent_tool_use_id` from events to link children to Tasks
- **Duration tracking:** Set `startedAt` when created, `endedAt` when result arrives

### Subagent Tools on Reload (D016)

Subagent tools live in separate transcript files (`{agentId}.jsonl`). For historical sessions:

- **Rust:** `parse_transcript_with_subagents()` loads main + subagent transcripts
- **Returns:** `subagentTools[]` with `parentToolId` set to Task tool ID
- **Frontend:** `mergeSubagentTools()` adds them to `toolsById` (no parent message)
- **MessageList:** Use `useAllTools()` selector or accept `allTools` prop

```ts
// ‚úÖ CORRECT - includes subagent tools from store
const allTools = useAllTools(sessionId)

// ‚ùå WRONG - misses subagent tools (they're not in any message)
const allTools = messages.flatMap(m => m.toolCalls || [])
```

---

## Code Rendering CSS

### @pierre/diffs Shadow DOM

The library uses Shadow DOM. Critical fixes:

1. **`color: unset`** on `diffs-container`
2. **CSS variable overrides** on host element (not inside Shadow DOM)
3. **`light-dark()` fallback** for browser compatibility

### Streamdown Class

Must pass explicitly:
```jsx
<Streamdown className="streamdown" />
```

### Shiki Override

```jsx
[&>pre]:bg-background! [&>pre]:text-foreground!
```

---

## Debug

```bash
tail -f horseman-debug.log              # Watch live
grep "Resume session" horseman-debug.log # Check session handling
grep STDERR horseman-debug.log          # Claude errors
```

Verify session isolation:
```
[SPAWN] Resume session: None        # ‚Üê New session (correct)
[SPAWN] Resume session: Some("x")   # ‚Üê Follow-up (correct)
```

If new sessions show `Some(...)`, the ref sync is broken.

---

## Known Limitations

- Multiple Claude processes can run simultaneously
- MCP permissions are global (no session context)
- In-app sessions need restart to discover transcripts
